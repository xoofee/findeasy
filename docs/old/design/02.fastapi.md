   db.places.insertOne({
     "name": "East Coast Car Park E1",
     "address": "ECP Service Rd, East Coast, Singapore",
     "location": { "type": "Point", "coordinates": [103.92936406404, 1.30704350174] },
     "parking_lots":  ["E1"],
   })
   db.places.insertOne({
     "name": "番禺天河城",
     "address": "番禺区南村镇万博一路",
     "location": { "type": "Point", "coordinates": [113.3431710, 23.0061835] },
     "parking_lots":  ["B1", "B2"],
   })
   db.places.insertOne({
     "name": "番禺万达广场",
     "address": "广州市番禺区汉溪大道东368号",
     "location": { "type": "Point", "coordinates": [113.3439625, 23.0096088] },
     "parking_lots":  ["B1", "B2"],
   })
db.places.createIndex({ location: "2dsphere" })

I have a mongo db as above, write an api backend for it. besides the basic crud, place find with user's gps location, I also want a download url provider. to return http://ip/d/findeasy/places/{document_id}/{parking_lots}.zip

write in python.

---

Sure! Let's rewrite the backend API using **FastAPI**, which is a modern Python web framework for building APIs with fast performance, easy integration with MongoDB, and automatic generation of OpenAPI documentation.

We'll use **`pymongo`** to interact with MongoDB, as it's the official MongoDB driver for Python. FastAPI is asynchronous, so we’ll use **async** and **await** with MongoDB operations to keep the API efficient.

### 1. **Install Required Libraries**

First, you need to install **FastAPI**, **uvicorn** (for running the server), and **pymongo**.

```bash
pip3 install fastapi uvicorn pymongo
```

### 2. **Create the FastAPI App**

Let's start by setting up the FastAPI application and routes.

#### **File Structure**:

```
places-api/
├── main.py           # FastAPI app and routes
├── models.py         # MongoDB schema
└── .env              # Environment variables (like MongoDB URI)
```

### 3. **Create `.env` for Environment Variables**

We'll use a `.env` file to store MongoDB connection URI and other environment variables:

#### `.env`

```env
MONGODB_URI=mongodb://localhost:27017/placesDB
PORT=8000
```

### 4. **Create the MongoDB Schema**

You don't need to define models in FastAPI directly, but it's helpful to have a schema-like structure for validation. We will define Pydantic models for data validation and then use **`pymongo`** to interact with MongoDB.

#### **models.py**

```python
from pydantic import BaseModel
from typing import List, Optional
from bson import ObjectId

# Pydantic model for Place
class Location(BaseModel):
    type: str
    coordinates: List[float]

class Place(BaseModel):
    name: str
    address: str
    location: Location
    parking_lots: List[str]

    class Config:
        # Allow ObjectId type for MongoDB compatibility
        json_encoders = {
            ObjectId: str
        }

class PlaceInDB(Place):
    id: str
```

In this example, `Place` is the model used for input validation, while `PlaceInDB` includes the `id` field that MongoDB generates automatically.

### 5. **Create the FastAPI Application**

We now set up FastAPI with endpoints for CRUD operations, geospatial queries, and download URL generation.

#### **main.py**

```python
import os
from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from pymongo import MongoClient
from bson import ObjectId
from dotenv import load_dotenv

# Load environment variables from .env
load_dotenv()

# MongoDB connection
client = MongoClient(os.getenv("MONGODB_URI"))
db = client.placesDB
places_collection = db.places

# FastAPI application
app = FastAPI()

# Pydantic model for input validation
class Location(BaseModel):
    type: str
    coordinates: list[float]

class Place(BaseModel):
    name: str
    address: str
    location: Location
    parking_lots: list[str]

class PlaceInDB(Place):
    id: str

# Create an index on the location field for geospatial queries
places_collection.create_index([("location", "2dsphere")])

@app.post("/places/", response_model=PlaceInDB)
async def create_place(place: Place):
    # Insert the place into MongoDB
    place_data = place.dict()
    result = places_collection.insert_one(place_data)
    
    # Return the inserted place with its generated ID
    place_data["id"] = str(result.inserted_id)
    return place_data

@app.get("/places/", response_model=list[PlaceInDB])
async def get_all_places():
    places = places_collection.find()
    return [PlaceInDB(**place) for place in places]

@app.get("/places/{place_id}", response_model=PlaceInDB)
async def get_place(place_id: str):
    place = places_collection.find_one({"_id": ObjectId(place_id)})
    if place is None:
        raise HTTPException(status_code=404, detail="Place not found")
    return PlaceInDB(**place)

@app.get("/places/near", response_model=list[PlaceInDB])
async def get_nearby_places(lat: float, lon: float, max_distance: int = 5000):
    # Perform geospatial query to find places near the given location
    places = places_collection.find({
        "location": {
            "$near": {
                "$geometry": {
                    "type": "Point",
                    "coordinates": [lon, lat]
                },
                "$maxDistance": max_distance  # In meters
            }
        }
    })
    return [PlaceInDB(**place) for place in places]

@app.get("/places/download/{place_id}/{parking_lot}.zip")
async def generate_download_url(place_id: str, parking_lot: str):
    # Check if the place exists and if the parking lot is valid
    place = places_collection.find_one({"_id": ObjectId(place_id)})
    if not place:
        raise HTTPException(status_code=404, detail="Place not found")

    if parking_lot not in place.get("parking_lots", []):
        raise HTTPException(status_code=400, detail="Parking lot not found")
    
    # Construct the download URL
    download_url = f"http://{os.getenv('HOST_IP', 'xoofee.top')}:{os.getenv('PORT', 5001)}/d/findeasy/places/{place_id}/{parking_lot}.zip"
    return {"download_url": download_url}
```

### Explanation of Endpoints:

1. **`POST /places/`**: Creates a new place in the database. Returns the newly created place along with its generated MongoDB `_id`.
2. **`GET /places/`**: Fetches all places from the database.
3. **`GET /places/{place_id}`**: Fetches a place by its `id`.
4. **`GET /places/near`**: Finds places near a user's GPS location using a geospatial query. You can specify a `max_distance` parameter (in meters, default is 5000 meters or 5 km).
5. **`GET /places/download/{place_id}/{parking_lot}.zip`**: Generates a download URL for a parking lot ZIP file based on the `place_id` and `parking_lot` provided. It checks if the parking lot exists for that place.

### 6. **Run the FastAPI Server**

Run the FastAPI application with **uvicorn**:

```bash
uvicorn main:app --reload
```

This will start the FastAPI server, and you can access the API at `http://127.0.0.1:8000`.

### 7. **Test the API**

1. **Create a Place**:

```bash
POST /places/
Content-Type: application/json

{
  "name": "East Coast Car Park E1",
  "address": "ECP Service Rd, East Coast, Singapore",
  "location": { "type": "Point", "coordinates": [103.92936406404, 1.30704350174] },
  "parking_lots": ["E1"]
}
```

2. **Get All Places**:

```bash
GET /places/
```

3. **Get Place by ID**:

```bash
GET /places/{place_id}
```

4. **Find Places Near User Location**:

```bash
GET /places/near?lat=1.30704350174&lon=103.92936406404&max_distance=5000
```

5. **Generate Download URL**:

```bash
GET /places/download/{place_id}/{parking_lot}.zip
```

### 8. **Summary**

- The **FastAPI** backend is now set up with **CRUD operations**, **geospatial queries** to find places near a user’s GPS location, and **dynamic download URLs** for parking lots.
- The **`/places/download/{place_id}/{parking_lot}.zip`** endpoint generates a URL for downloading the parking lot's ZIP file.
- The API is fast, scalable, and efficient, leveraging **asynchronous programming** and **geospatial indexing**.

With this setup, you have a powerful, fast backend API for managing places and serving dynamic download links for parking lots based on MongoDB data.

---

## Adding API Key Authentication
```
from starlette.middleware.base import BaseHTTPMiddleware
from fastapi import Request, HTTPException

class APIKeyMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        api_key = request.headers.get("X-API-Key")
        if api_key != "secret-api-key":
            raise HTTPException(status_code=403, detail="Forbidden")
        response = await call_next(request)
        return response

# Add the middleware to the FastAPI app
app.add_middleware(APIKeyMiddleware)
```